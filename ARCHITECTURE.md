# Архитектурные рекомендации для плагина Prom Import

Этот документ описывает текущее состояние архитектуры и предлагает улучшения, направленные на устойчивость, расширяемость и тестопригодность плагина. Текст ориентирован на текущую структуру кода проекта и WordPress-окружение.

## 1) Краткий обзор текущей архитектуры
- Слоистая структура (Domain / Application / Infrastructure / Presentation).
- Внедрение зависимостей через PHP-DI и фабрику ContainerConfig.
- Интеграция с WordPress: регистрация хуков через HookRegistrar, контроллеры для Admin UI и Ajax (Presentation), репозитории в Infrastructure.
- Application слой содержит ImportService, XmlService, XmlParser, DTO.

Сильные стороны:
- Уже отделены доменные интерфейсы репозиториев от реализаций.
- Используется DI-контейнер вместо жёстких связей.
- Presentation слой не смешан с доменной логикой.

Зоны роста:
- Явное разделение адаптеров для WordPress API и общих портов.
- Обработка ошибок/результатов, стратегия ретраев, идемпотентность.
- Стриминговая обработка больших XML, фоновая/пакетная обработка.
- Наблюдаемость, логирование, метрики.
- Консистентность конфигурации и расширяемость на уровне контейнера.

## 2) Предлагаемая целевая модель: Ports & Adapters (Hexagonal)
Ввести чёткие портовые интерфейсы в Application/Domain и адаптеры в Infrastructure/Presentation.

- Входные порты (Application Ports):
  - ImportProductsPort: команды для запуска импорта (sync/async, по страницам, по категориям).
  - ManageMappingsPort: управление маппингами категорий.
  - FeedFetchPort: запрос и валидация фида.

- Выходные порты (Driven Ports):
  - ProductRepository, CategoryMappingRepository (есть), MediaStorage (загрузка/кеширование изображений), FeedRepository (есть, уточнить обязанности), TaskQueue (фоновые задания), Logger, Clock, IdempotencyStore.

- Адаптеры:
  - WordPressAdapters: реализация репозиториев поверх WP/WooCommerce API, загрузка медиа через wp_handle_sideload и т. п.
  - HttpClientAdapter: обёртка WpHttpClient (есть) + ретраи/тайм-ауты.
  - ActionSchedulerAdapter или WP-Cron/queue для фоновых задач.

Преимущества: высокая тестируемость Application слоя без WP, гибкость замены инфраструктуры.

## 3) Командная модель и шина (Command Handlers)
В Application слое выделить команды и обработчики:
- ImportProductCommand, ImportCategoryCommand, ImportFeedCommand, ImportPageCommand.
- Хендлеры принимают валидированные DTO/ValueObjects и возвращают Result (успех/ошибка, диагностическая информация).
- Тонкие контроллеры Presentation только собирают ввод (HTTP/nonce/options), вызывают хендлер, сериализуют ответ в JSON/HTML.

Можно обойтись без отдельной «шины», зарегистрировав обработчики в контейнере, однако интерфейс ICommandHandler упростит расширение.

## 4) Обработка ошибок и тип результата
Заменить WP_Error в Application/Domain на собственный тип Result:
- Result<T> с подтипами Ok(value) и Err(code, message, context).
- На границах с WordPress (Presentation/Infrastructure) конвертировать в WP_Error, HTTP коды, admin notice и т. п.
- Внедрить коды ошибок (enum-like) для машинной обработки и ретраев.

## 5) Валидация входа и контрактов
- Валидация DTO (например, при помощи простых валидаторов или сторонних библиотек) до входа в хендлер.
- Ввести ValueObject-ы для URL, Money/Price (частично есть), Sku, CategoryId (включая внешний и внутренний ID), ImageUrl. Это снизит количество неявных предположений.

## 6) Асинхронность, пакетная обработка и идемпотентность
- Ввести TaskQueue порт с адаптером на Action Scheduler (рекомендуется для WooCommerce) или WP-Cron.
- Импорт продукций — пачками: размер батча и задержка — настройки.
- Идемпотентность: ключ по внешнему ID/SKU для предотвращения дублей при ретраях.
- Политики ретраев: экспоненциальный backoff для сетевых/временных ошибок, без ретрая для валидационных.

## 7) Стриминговая обработка крупных XML
- XmlParser порт с реализацией на XMLReader или Sabre/XML для потокового чтения, без загрузки всего дерева в память.
- Инкрементальная отправка найденных элементов в хендлеры, поддержка «checkpoint» (сохранение позиции для возобновления).

## 8) Медиа, кеш и лимиты
- MediaStorage порт: скачивание изображений с кешем (по хешу URL или ETag/Last-Modified), ограничение размера, контроль типов.
- RateLimiter порт (токен-бакет в опциях/транзиентах) для внешних API.
- Локальный дисковый кеш и/или объектный кеш WP для неизменяемых справочников (категории).

## 9) Конфигурация и секреты
- Единый Config порт, чтение из: настроек WP (options), констант, окружения. Явные схемы и дефолты.
- Feature flags для включения бэкграунд-импорта, расширенных логов и т. п.

## 10) Наблюдаемость: логи, метрики, трассировка
- Logger порт (PSR-3) с адаптером на error_log/WP-CLI/файлы.
- Событийная телеметрия: ImportStarted, ProductImported, ProductFailed, ImportCompleted — публикация событий (Domain Events) и Event Bus (упрощённый). Адаптеры: лог, UI-прогресс, метрики.
- Метрики: счётчики, таймеры (в простейшем варианте — агрегаты в опциях + экспорт в CSV для анализа).

## 11) API уровня Presentation
- Ajax эндпоинты и WP-CLI команды поверх одних и тех же хендлеров.
- Nonce/permissions: единая утилита SecurityPolicy для проверки прав, капабилити и nonce.
- Pagination и реальный прогресс: UI подписывается на события/метрики.

## 12) Улучшения DI и структуры контейнера
- Разделить ContainerConfig на модули: ApplicationModule, InfrastructureModule, PresentationModule.
- Явно регистрировать порты/адаптеры. Для окружений тест/прод подменять адаптеры (например, HttpClient на MockHttpClient в тестах).

## 13) Тестирование
- Unit: Application/Domain с подменой портов.
- Contract tests: репозитории — соответствие интерфейсу на общих наборах тестов.
- Integration: поверх реально поднятого WP (wp-env) или с использованием Brain Monkey для хуков.
- E2E: WP-CLI сценарии на малых фидах.

## 14) ADR (Architecture Decision Records)
- Ввести каталог docs/adr с короткими ADR (1 файл = 1 решение). Пример: «Adopt Ports & Adapters», «Use Action Scheduler», «Use XMLReader streaming parser».

## 15) Безопасность
- Ограничение прав (manage_woocommerce).
- Валидация URL фида, запрет file://, ограничение размеров ответа, тайм-ауты.
- Санитайзинг всех строк, whitelisting HTML.

## 16) Совместимость и производительность
- Минимизировать прямые вызовы глобальных WP-функций в Application/Domain.
- Кэшировать неизменяемые данные и избегать лишних WP-запросов.
- Предусмотреть миграции опций/схем.

---

## Пошаговый план внедрения (итеративно)
1. Ввести Result тип и Value Objects для ключевых полей. Обновить ImportService для возврата Result вместо WP_Error на уровне Application. На границах — конверсия. 
2. Выделить порты и адаптеры, разнести по модулям контейнера. 
3. Подключить Action Scheduler и добавить импорт партиями + идемпотентность. 
4. Перейти на потоковый XmlParser. 
5. Добавить Logger/Events и базовые метрики. 
6. Улучшить UI: прогресс, пагинация, фильтры; дублировать команды в WP-CLI. 
7. Тестовое покрытие: контрактные и интеграционные тесты.

Эти изменения можно внедрять постепенно без массовых ломок публичного API, сохраняя обратную совместимость через слой адаптеров.
